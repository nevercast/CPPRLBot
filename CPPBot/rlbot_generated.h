// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RLBOT_RLBOT_FLAT_H_
#define FLATBUFFERS_GENERATED_RLBOT_RLBOT_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace rlbot {
namespace flat {

struct ControllerState;

struct PlayerInput;

struct Vector3;

struct Rotator;

struct Quaternion;

struct Touch;

struct ScoreInfo;

struct Physics;

struct PlayerInfo;

struct DropShotBallInfo;

struct BallInfo;

struct BoostPadState;

struct DropshotTile;

struct GameInfo;

struct GameTickPacket;

struct RigidBodyState;

struct PlayerRigidBodyState;

struct BallRigidBodyState;

struct RigidBodyTick;

struct GoalInfo;

struct BoostPad;

struct FieldInfo;

struct Float;

struct Bool;

struct Vector3Partial;

struct RotatorPartial;

struct DesiredPhysics;

struct DesiredBallState;

struct DesiredCarState;

struct DesiredBoostState;

struct DesiredGameInfoState;

struct DesiredGameState;

struct Color;

struct RenderMessage;

struct RenderGroup;

struct QuickChat;

struct TinyPlayer;

struct TinyBall;

struct TinyPacket;

struct PredictionSlice;

struct BallPrediction;

enum TileState {
  TileState_Unknown = 0  /// The default state of the tiles.
,
  TileState_Filled = 1  /// The state when a tile has been damaged.
,
  TileState_Damaged = 2  /// The state of a tile when it is open and a goal can be scored.
,
  TileState_Open = 3,
  TileState_MIN = TileState_Unknown,
  TileState_MAX = TileState_Open
};

inline const TileState (&EnumValuesTileState())[4] {
  static const TileState values[] = {
    TileState_Unknown,
    TileState_Filled,
    TileState_Damaged,
    TileState_Open
  };
  return values;
}

inline const char * const *EnumNamesTileState() {
  static const char * const names[] = {
    "Unknown",
    "Filled",
    "Damaged",
    "Open",
    nullptr
  };
  return names;
}

inline const char *EnumNameTileState(TileState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTileState()[index];
}

enum RenderType {
  RenderType_DrawLine2D = 1,
  RenderType_DrawLine3D = 2,
  RenderType_DrawLine2D_3D = 3,
  RenderType_DrawRect2D = 4,
  RenderType_DrawRect3D = 5,
  RenderType_DrawString2D = 6,
  RenderType_DrawString3D = 7,
  RenderType_DrawCenteredRect3D = 8,
  RenderType_MIN = RenderType_DrawLine2D,
  RenderType_MAX = RenderType_DrawCenteredRect3D
};

inline const RenderType (&EnumValuesRenderType())[8] {
  static const RenderType values[] = {
    RenderType_DrawLine2D,
    RenderType_DrawLine3D,
    RenderType_DrawLine2D_3D,
    RenderType_DrawRect2D,
    RenderType_DrawRect3D,
    RenderType_DrawString2D,
    RenderType_DrawString3D,
    RenderType_DrawCenteredRect3D
  };
  return values;
}

inline const char * const *EnumNamesRenderType() {
  static const char * const names[] = {
    "DrawLine2D",
    "DrawLine3D",
    "DrawLine2D_3D",
    "DrawRect2D",
    "DrawRect3D",
    "DrawString2D",
    "DrawString3D",
    "DrawCenteredRect3D",
    nullptr
  };
  return names;
}

inline const char *EnumNameRenderType(RenderType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(RenderType_DrawLine2D);
  return EnumNamesRenderType()[index];
}

enum QuickChatSelection {
  QuickChatSelection_Information_IGotIt = 0,
  QuickChatSelection_Information_NeedBoost = 1,
  QuickChatSelection_Information_TakeTheShot = 2,
  QuickChatSelection_Information_Defending = 3,
  QuickChatSelection_Information_GoForIt = 4,
  QuickChatSelection_Information_Centering = 5,
  QuickChatSelection_Information_AllYours = 6,
  QuickChatSelection_Information_InPosition = 7,
  QuickChatSelection_Information_Incoming = 8,
  QuickChatSelection_Compliments_NiceShot = 9,
  QuickChatSelection_Compliments_GreatPass = 10,
  QuickChatSelection_Compliments_Thanks = 11,
  QuickChatSelection_Compliments_WhatASave = 12,
  QuickChatSelection_Compliments_NiceOne = 13,
  QuickChatSelection_Compliments_WhatAPlay = 14,
  QuickChatSelection_Compliments_GreatClear = 15,
  QuickChatSelection_Compliments_NiceBlock = 16,
  QuickChatSelection_Reactions_OMG = 17,
  QuickChatSelection_Reactions_Noooo = 18,
  QuickChatSelection_Reactions_Wow = 19,
  QuickChatSelection_Reactions_CloseOne = 20,
  QuickChatSelection_Reactions_NoWay = 21,
  QuickChatSelection_Reactions_HolyCow = 22,
  QuickChatSelection_Reactions_Whew = 23,
  QuickChatSelection_Reactions_Siiiick = 24,
  QuickChatSelection_Reactions_Calculated = 25,
  QuickChatSelection_Reactions_Savage = 26,
  QuickChatSelection_Reactions_Okay = 27,
  QuickChatSelection_Apologies_Cursing = 28,
  QuickChatSelection_Apologies_NoProblem = 29,
  QuickChatSelection_Apologies_Whoops = 30,
  QuickChatSelection_Apologies_Sorry = 31,
  QuickChatSelection_Apologies_MyBad = 32,
  QuickChatSelection_Apologies_Oops = 33,
  QuickChatSelection_Apologies_MyFault = 34,
  QuickChatSelection_PostGame_Gg = 35,
  QuickChatSelection_PostGame_WellPlayed = 36,
  QuickChatSelection_PostGame_ThatWasFun = 37,
  QuickChatSelection_PostGame_Rematch = 38,
  QuickChatSelection_PostGame_OneMoreGame = 39,
  QuickChatSelection_PostGame_WhatAGame = 40,
  QuickChatSelection_PostGame_NiceMoves = 41,
  QuickChatSelection_PostGame_EverybodyDance = 42  /// Custom text chats made by bot makers
,
  QuickChatSelection_MaxPysonixQuickChatPresets = 43  /// Waste of CPU cycles
,
  QuickChatSelection_Custom_Toxic_WasteCPU = 44  /// Git gud*
,
  QuickChatSelection_Custom_Toxic_GitGut = 45  /// De-Allocate Yourself
,
  QuickChatSelection_Custom_Toxic_DeAlloc = 46  /// 404: Your skill not found
,
  QuickChatSelection_Custom_Toxic_404NoSkill = 47  /// Get a virus
,
  QuickChatSelection_Custom_Toxic_CatchVirus = 48  /// Passing!
,
  QuickChatSelection_Custom_Useful_Passing = 49  /// Faking!
,
  QuickChatSelection_Custom_Useful_Faking = 50  /// Demoing!
,
  QuickChatSelection_Custom_Useful_Demoing = 51  /// BOOPING
,
  QuickChatSelection_Custom_Useful_Bumping = 52  /// The chances of that was 47525 to 1*
,
  QuickChatSelection_Custom_Compliments_TinyChances = 53  /// Who upped your skill level?
,
  QuickChatSelection_Custom_Compliments_SkillLevel = 54  /// Your programmer should be proud
,
  QuickChatSelection_Custom_Compliments_proud = 55  /// You're the GC of Bots
,
  QuickChatSelection_Custom_Compliments_GC = 56  /// Are you <Insert Pro>Bot? *
,
  QuickChatSelection_Custom_Compliments_Pro = 57,
  QuickChatSelection_MIN = QuickChatSelection_Information_IGotIt,
  QuickChatSelection_MAX = QuickChatSelection_Custom_Compliments_Pro
};

inline const QuickChatSelection (&EnumValuesQuickChatSelection())[58] {
  static const QuickChatSelection values[] = {
    QuickChatSelection_Information_IGotIt,
    QuickChatSelection_Information_NeedBoost,
    QuickChatSelection_Information_TakeTheShot,
    QuickChatSelection_Information_Defending,
    QuickChatSelection_Information_GoForIt,
    QuickChatSelection_Information_Centering,
    QuickChatSelection_Information_AllYours,
    QuickChatSelection_Information_InPosition,
    QuickChatSelection_Information_Incoming,
    QuickChatSelection_Compliments_NiceShot,
    QuickChatSelection_Compliments_GreatPass,
    QuickChatSelection_Compliments_Thanks,
    QuickChatSelection_Compliments_WhatASave,
    QuickChatSelection_Compliments_NiceOne,
    QuickChatSelection_Compliments_WhatAPlay,
    QuickChatSelection_Compliments_GreatClear,
    QuickChatSelection_Compliments_NiceBlock,
    QuickChatSelection_Reactions_OMG,
    QuickChatSelection_Reactions_Noooo,
    QuickChatSelection_Reactions_Wow,
    QuickChatSelection_Reactions_CloseOne,
    QuickChatSelection_Reactions_NoWay,
    QuickChatSelection_Reactions_HolyCow,
    QuickChatSelection_Reactions_Whew,
    QuickChatSelection_Reactions_Siiiick,
    QuickChatSelection_Reactions_Calculated,
    QuickChatSelection_Reactions_Savage,
    QuickChatSelection_Reactions_Okay,
    QuickChatSelection_Apologies_Cursing,
    QuickChatSelection_Apologies_NoProblem,
    QuickChatSelection_Apologies_Whoops,
    QuickChatSelection_Apologies_Sorry,
    QuickChatSelection_Apologies_MyBad,
    QuickChatSelection_Apologies_Oops,
    QuickChatSelection_Apologies_MyFault,
    QuickChatSelection_PostGame_Gg,
    QuickChatSelection_PostGame_WellPlayed,
    QuickChatSelection_PostGame_ThatWasFun,
    QuickChatSelection_PostGame_Rematch,
    QuickChatSelection_PostGame_OneMoreGame,
    QuickChatSelection_PostGame_WhatAGame,
    QuickChatSelection_PostGame_NiceMoves,
    QuickChatSelection_PostGame_EverybodyDance,
    QuickChatSelection_MaxPysonixQuickChatPresets,
    QuickChatSelection_Custom_Toxic_WasteCPU,
    QuickChatSelection_Custom_Toxic_GitGut,
    QuickChatSelection_Custom_Toxic_DeAlloc,
    QuickChatSelection_Custom_Toxic_404NoSkill,
    QuickChatSelection_Custom_Toxic_CatchVirus,
    QuickChatSelection_Custom_Useful_Passing,
    QuickChatSelection_Custom_Useful_Faking,
    QuickChatSelection_Custom_Useful_Demoing,
    QuickChatSelection_Custom_Useful_Bumping,
    QuickChatSelection_Custom_Compliments_TinyChances,
    QuickChatSelection_Custom_Compliments_SkillLevel,
    QuickChatSelection_Custom_Compliments_proud,
    QuickChatSelection_Custom_Compliments_GC,
    QuickChatSelection_Custom_Compliments_Pro
  };
  return values;
}

inline const char * const *EnumNamesQuickChatSelection() {
  static const char * const names[] = {
    "Information_IGotIt",
    "Information_NeedBoost",
    "Information_TakeTheShot",
    "Information_Defending",
    "Information_GoForIt",
    "Information_Centering",
    "Information_AllYours",
    "Information_InPosition",
    "Information_Incoming",
    "Compliments_NiceShot",
    "Compliments_GreatPass",
    "Compliments_Thanks",
    "Compliments_WhatASave",
    "Compliments_NiceOne",
    "Compliments_WhatAPlay",
    "Compliments_GreatClear",
    "Compliments_NiceBlock",
    "Reactions_OMG",
    "Reactions_Noooo",
    "Reactions_Wow",
    "Reactions_CloseOne",
    "Reactions_NoWay",
    "Reactions_HolyCow",
    "Reactions_Whew",
    "Reactions_Siiiick",
    "Reactions_Calculated",
    "Reactions_Savage",
    "Reactions_Okay",
    "Apologies_Cursing",
    "Apologies_NoProblem",
    "Apologies_Whoops",
    "Apologies_Sorry",
    "Apologies_MyBad",
    "Apologies_Oops",
    "Apologies_MyFault",
    "PostGame_Gg",
    "PostGame_WellPlayed",
    "PostGame_ThatWasFun",
    "PostGame_Rematch",
    "PostGame_OneMoreGame",
    "PostGame_WhatAGame",
    "PostGame_NiceMoves",
    "PostGame_EverybodyDance",
    "MaxPysonixQuickChatPresets",
    "Custom_Toxic_WasteCPU",
    "Custom_Toxic_GitGut",
    "Custom_Toxic_DeAlloc",
    "Custom_Toxic_404NoSkill",
    "Custom_Toxic_CatchVirus",
    "Custom_Useful_Passing",
    "Custom_Useful_Faking",
    "Custom_Useful_Demoing",
    "Custom_Useful_Bumping",
    "Custom_Compliments_TinyChances",
    "Custom_Compliments_SkillLevel",
    "Custom_Compliments_proud",
    "Custom_Compliments_GC",
    "Custom_Compliments_Pro",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuickChatSelection(QuickChatSelection e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQuickChatSelection()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() {
    memset(this, 0, sizeof(Vector3));
  }
  Vector3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vector3, 12);

/// Expresses the rotation state of an object in Euler angles, with values in radians.
MANUALLY_ALIGNED_STRUCT(4) Rotator FLATBUFFERS_FINAL_CLASS {
 private:
  float pitch_;
  float yaw_;
  float roll_;

 public:
  Rotator() {
    memset(this, 0, sizeof(Rotator));
  }
  Rotator(float _pitch, float _yaw, float _roll)
      : pitch_(flatbuffers::EndianScalar(_pitch)),
        yaw_(flatbuffers::EndianScalar(_yaw)),
        roll_(flatbuffers::EndianScalar(_roll)) {
  }
  float pitch() const {
    return flatbuffers::EndianScalar(pitch_);
  }
  float yaw() const {
    return flatbuffers::EndianScalar(yaw_);
  }
  float roll() const {
    return flatbuffers::EndianScalar(roll_);
  }
};
STRUCT_END(Rotator, 12);

/// Expresses the rotation state of an object.
/// Learn about quaternions here: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
/// You can tinker with them here to build an intuition: https://quaternions.online/
MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quaternion() {
    memset(this, 0, sizeof(Quaternion));
  }
  Quaternion(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Quaternion, 16);

MANUALLY_ALIGNED_STRUCT(4) Float FLATBUFFERS_FINAL_CLASS {
 private:
  float val_;

 public:
  Float() {
    memset(this, 0, sizeof(Float));
  }
  Float(float _val)
      : val_(flatbuffers::EndianScalar(_val)) {
  }
  float val() const {
    return flatbuffers::EndianScalar(val_);
  }
};
STRUCT_END(Float, 4);

MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t val_;

 public:
  Bool() {
    memset(this, 0, sizeof(Bool));
  }
  Bool(bool _val)
      : val_(flatbuffers::EndianScalar(static_cast<uint8_t>(_val))) {
  }
  bool val() const {
    return flatbuffers::EndianScalar(val_) != 0;
  }
};
STRUCT_END(Bool, 1);

struct ControllerState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_THROTTLE = 4,
    VT_STEER = 6,
    VT_PITCH = 8,
    VT_YAW = 10,
    VT_ROLL = 12,
    VT_JUMP = 14,
    VT_BOOST = 16,
    VT_HANDBRAKE = 18
  };
  /// -1 for full reverse, 1 for full forward
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  /// -1 for full left, 1 for full right
  float steer() const {
    return GetField<float>(VT_STEER, 0.0f);
  }
  /// -1 for nose down, 1 for nose up
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  /// -1 for full left, 1 for full right
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  /// -1 for roll left, 1 for roll right
  float roll() const {
    return GetField<float>(VT_ROLL, 0.0f);
  }
  /// true if you want to press the jump button
  bool jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  /// true if you want to press the boost button
  bool boost() const {
    return GetField<uint8_t>(VT_BOOST, 0) != 0;
  }
  /// true if you want to press the handbrake button
  bool handbrake() const {
    return GetField<uint8_t>(VT_HANDBRAKE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_STEER) &&
           VerifyField<float>(verifier, VT_PITCH) &&
           VerifyField<float>(verifier, VT_YAW) &&
           VerifyField<float>(verifier, VT_ROLL) &&
           VerifyField<uint8_t>(verifier, VT_JUMP) &&
           VerifyField<uint8_t>(verifier, VT_BOOST) &&
           VerifyField<uint8_t>(verifier, VT_HANDBRAKE) &&
           verifier.EndTable();
  }
};

struct ControllerStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(ControllerState::VT_THROTTLE, throttle, 0.0f);
  }
  void add_steer(float steer) {
    fbb_.AddElement<float>(ControllerState::VT_STEER, steer, 0.0f);
  }
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(ControllerState::VT_PITCH, pitch, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(ControllerState::VT_YAW, yaw, 0.0f);
  }
  void add_roll(float roll) {
    fbb_.AddElement<float>(ControllerState::VT_ROLL, roll, 0.0f);
  }
  void add_jump(bool jump) {
    fbb_.AddElement<uint8_t>(ControllerState::VT_JUMP, static_cast<uint8_t>(jump), 0);
  }
  void add_boost(bool boost) {
    fbb_.AddElement<uint8_t>(ControllerState::VT_BOOST, static_cast<uint8_t>(boost), 0);
  }
  void add_handbrake(bool handbrake) {
    fbb_.AddElement<uint8_t>(ControllerState::VT_HANDBRAKE, static_cast<uint8_t>(handbrake), 0);
  }
  explicit ControllerStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerStateBuilder &operator=(const ControllerStateBuilder &);
  flatbuffers::Offset<ControllerState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerState> CreateControllerState(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float steer = 0.0f,
    float pitch = 0.0f,
    float yaw = 0.0f,
    float roll = 0.0f,
    bool jump = false,
    bool boost = false,
    bool handbrake = false) {
  ControllerStateBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  builder_.add_steer(steer);
  builder_.add_throttle(throttle);
  builder_.add_handbrake(handbrake);
  builder_.add_boost(boost);
  builder_.add_jump(jump);
  return builder_.Finish();
}

struct PlayerInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERINDEX = 4,
    VT_CONTROLLERSTATE = 6
  };
  int32_t playerIndex() const {
    return GetField<int32_t>(VT_PLAYERINDEX, 0);
  }
  const ControllerState *controllerState() const {
    return GetPointer<const ControllerState *>(VT_CONTROLLERSTATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERINDEX) &&
           VerifyOffset(verifier, VT_CONTROLLERSTATE) &&
           verifier.VerifyTable(controllerState()) &&
           verifier.EndTable();
  }
};

struct PlayerInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerIndex(int32_t playerIndex) {
    fbb_.AddElement<int32_t>(PlayerInput::VT_PLAYERINDEX, playerIndex, 0);
  }
  void add_controllerState(flatbuffers::Offset<ControllerState> controllerState) {
    fbb_.AddOffset(PlayerInput::VT_CONTROLLERSTATE, controllerState);
  }
  explicit PlayerInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerInputBuilder &operator=(const PlayerInputBuilder &);
  flatbuffers::Offset<PlayerInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerInput> CreatePlayerInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerIndex = 0,
    flatbuffers::Offset<ControllerState> controllerState = 0) {
  PlayerInputBuilder builder_(_fbb);
  builder_.add_controllerState(controllerState);
  builder_.add_playerIndex(playerIndex);
  return builder_.Finish();
}

struct Touch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERNAME = 4,
    VT_GAMESECONDS = 6,
    VT_LOCATION = 8,
    VT_NORMAL = 10
  };
  /// The name of the player involved with the touch.
  const flatbuffers::String *playerName() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYERNAME);
  }
  /// Seconds that had elapsed in the game when the touch occurred.
  float gameSeconds() const {
    return GetField<float>(VT_GAMESECONDS, 0.0f);
  }
  /// The point of contact for the touch.
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  /// The direction of the touch.
  const Vector3 *normal() const {
    return GetStruct<const Vector3 *>(VT_NORMAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERNAME) &&
           verifier.Verify(playerName()) &&
           VerifyField<float>(verifier, VT_GAMESECONDS) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Vector3>(verifier, VT_NORMAL) &&
           verifier.EndTable();
  }
};

struct TouchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerName(flatbuffers::Offset<flatbuffers::String> playerName) {
    fbb_.AddOffset(Touch::VT_PLAYERNAME, playerName);
  }
  void add_gameSeconds(float gameSeconds) {
    fbb_.AddElement<float>(Touch::VT_GAMESECONDS, gameSeconds, 0.0f);
  }
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(Touch::VT_LOCATION, location);
  }
  void add_normal(const Vector3 *normal) {
    fbb_.AddStruct(Touch::VT_NORMAL, normal);
  }
  explicit TouchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TouchBuilder &operator=(const TouchBuilder &);
  flatbuffers::Offset<Touch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Touch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Touch> CreateTouch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> playerName = 0,
    float gameSeconds = 0.0f,
    const Vector3 *location = 0,
    const Vector3 *normal = 0) {
  TouchBuilder builder_(_fbb);
  builder_.add_normal(normal);
  builder_.add_location(location);
  builder_.add_gameSeconds(gameSeconds);
  builder_.add_playerName(playerName);
  return builder_.Finish();
}

inline flatbuffers::Offset<Touch> CreateTouchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *playerName = nullptr,
    float gameSeconds = 0.0f,
    const Vector3 *location = 0,
    const Vector3 *normal = 0) {
  return rlbot::flat::CreateTouch(
      _fbb,
      playerName ? _fbb.CreateString(playerName) : 0,
      gameSeconds,
      location,
      normal);
}

struct ScoreInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCORE = 4,
    VT_GOALS = 6,
    VT_OWNGOALS = 8,
    VT_ASSISTS = 10,
    VT_SAVES = 12,
    VT_SHOTS = 14,
    VT_DEMOLITIONS = 16
  };
  int32_t score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  int32_t goals() const {
    return GetField<int32_t>(VT_GOALS, 0);
  }
  int32_t ownGoals() const {
    return GetField<int32_t>(VT_OWNGOALS, 0);
  }
  int32_t assists() const {
    return GetField<int32_t>(VT_ASSISTS, 0);
  }
  int32_t saves() const {
    return GetField<int32_t>(VT_SAVES, 0);
  }
  int32_t shots() const {
    return GetField<int32_t>(VT_SHOTS, 0);
  }
  int32_t demolitions() const {
    return GetField<int32_t>(VT_DEMOLITIONS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCORE) &&
           VerifyField<int32_t>(verifier, VT_GOALS) &&
           VerifyField<int32_t>(verifier, VT_OWNGOALS) &&
           VerifyField<int32_t>(verifier, VT_ASSISTS) &&
           VerifyField<int32_t>(verifier, VT_SAVES) &&
           VerifyField<int32_t>(verifier, VT_SHOTS) &&
           VerifyField<int32_t>(verifier, VT_DEMOLITIONS) &&
           verifier.EndTable();
  }
};

struct ScoreInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_score(int32_t score) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_SCORE, score, 0);
  }
  void add_goals(int32_t goals) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_GOALS, goals, 0);
  }
  void add_ownGoals(int32_t ownGoals) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_OWNGOALS, ownGoals, 0);
  }
  void add_assists(int32_t assists) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_ASSISTS, assists, 0);
  }
  void add_saves(int32_t saves) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_SAVES, saves, 0);
  }
  void add_shots(int32_t shots) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_SHOTS, shots, 0);
  }
  void add_demolitions(int32_t demolitions) {
    fbb_.AddElement<int32_t>(ScoreInfo::VT_DEMOLITIONS, demolitions, 0);
  }
  explicit ScoreInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScoreInfoBuilder &operator=(const ScoreInfoBuilder &);
  flatbuffers::Offset<ScoreInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScoreInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScoreInfo> CreateScoreInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t score = 0,
    int32_t goals = 0,
    int32_t ownGoals = 0,
    int32_t assists = 0,
    int32_t saves = 0,
    int32_t shots = 0,
    int32_t demolitions = 0) {
  ScoreInfoBuilder builder_(_fbb);
  builder_.add_demolitions(demolitions);
  builder_.add_shots(shots);
  builder_.add_saves(saves);
  builder_.add_assists(assists);
  builder_.add_ownGoals(ownGoals);
  builder_.add_goals(goals);
  builder_.add_score(score);
  return builder_.Finish();
}

struct Physics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOCATION = 4,
    VT_ROTATION = 6,
    VT_VELOCITY = 8,
    VT_ANGULARVELOCITY = 10
  };
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  const Rotator *rotation() const {
    return GetStruct<const Rotator *>(VT_ROTATION);
  }
  const Vector3 *velocity() const {
    return GetStruct<const Vector3 *>(VT_VELOCITY);
  }
  const Vector3 *angularVelocity() const {
    return GetStruct<const Vector3 *>(VT_ANGULARVELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Rotator>(verifier, VT_ROTATION) &&
           VerifyField<Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<Vector3>(verifier, VT_ANGULARVELOCITY) &&
           verifier.EndTable();
  }
};

struct PhysicsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(Physics::VT_LOCATION, location);
  }
  void add_rotation(const Rotator *rotation) {
    fbb_.AddStruct(Physics::VT_ROTATION, rotation);
  }
  void add_velocity(const Vector3 *velocity) {
    fbb_.AddStruct(Physics::VT_VELOCITY, velocity);
  }
  void add_angularVelocity(const Vector3 *angularVelocity) {
    fbb_.AddStruct(Physics::VT_ANGULARVELOCITY, angularVelocity);
  }
  explicit PhysicsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PhysicsBuilder &operator=(const PhysicsBuilder &);
  flatbuffers::Offset<Physics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Physics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Physics> CreatePhysics(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3 *location = 0,
    const Rotator *rotation = 0,
    const Vector3 *velocity = 0,
    const Vector3 *angularVelocity = 0) {
  PhysicsBuilder builder_(_fbb);
  builder_.add_angularVelocity(angularVelocity);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_location(location);
  return builder_.Finish();
}

struct PlayerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PHYSICS = 4,
    VT_SCOREINFO = 6,
    VT_ISDEMOLISHED = 8,
    VT_HASWHEELCONTACT = 10,
    VT_ISSUPERSONIC = 12,
    VT_ISBOT = 14,
    VT_JUMPED = 16,
    VT_DOUBLEJUMPED = 18,
    VT_NAME = 20,
    VT_TEAM = 22,
    VT_BOOST = 24
  };
  const Physics *physics() const {
    return GetPointer<const Physics *>(VT_PHYSICS);
  }
  const ScoreInfo *scoreInfo() const {
    return GetPointer<const ScoreInfo *>(VT_SCOREINFO);
  }
  bool isDemolished() const {
    return GetField<uint8_t>(VT_ISDEMOLISHED, 0) != 0;
  }
  /// True if your wheels are on the ground, the wall, or the ceiling. False if you're midair or turtling.
  bool hasWheelContact() const {
    return GetField<uint8_t>(VT_HASWHEELCONTACT, 0) != 0;
  }
  bool isSupersonic() const {
    return GetField<uint8_t>(VT_ISSUPERSONIC, 0) != 0;
  }
  bool isBot() const {
    return GetField<uint8_t>(VT_ISBOT, 0) != 0;
  }
  /// True if the player has jumped. Falling off the ceiling / driving off the goal post does not count.
  bool jumped() const {
    return GetField<uint8_t>(VT_JUMPED, 0) != 0;
  }
  ///  True if player has double jumped. False does not mean you have a jump remaining, because the
  ///  aerial timer can run out, and that doesn't affect this flag.
  bool doubleJumped() const {
    return GetField<uint8_t>(VT_DOUBLEJUMPED, 0) != 0;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t team() const {
    return GetField<int32_t>(VT_TEAM, 0);
  }
  int32_t boost() const {
    return GetField<int32_t>(VT_BOOST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           VerifyOffset(verifier, VT_SCOREINFO) &&
           verifier.VerifyTable(scoreInfo()) &&
           VerifyField<uint8_t>(verifier, VT_ISDEMOLISHED) &&
           VerifyField<uint8_t>(verifier, VT_HASWHEELCONTACT) &&
           VerifyField<uint8_t>(verifier, VT_ISSUPERSONIC) &&
           VerifyField<uint8_t>(verifier, VT_ISBOT) &&
           VerifyField<uint8_t>(verifier, VT_JUMPED) &&
           VerifyField<uint8_t>(verifier, VT_DOUBLEJUMPED) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TEAM) &&
           VerifyField<int32_t>(verifier, VT_BOOST) &&
           verifier.EndTable();
  }
};

struct PlayerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physics(flatbuffers::Offset<Physics> physics) {
    fbb_.AddOffset(PlayerInfo::VT_PHYSICS, physics);
  }
  void add_scoreInfo(flatbuffers::Offset<ScoreInfo> scoreInfo) {
    fbb_.AddOffset(PlayerInfo::VT_SCOREINFO, scoreInfo);
  }
  void add_isDemolished(bool isDemolished) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_ISDEMOLISHED, static_cast<uint8_t>(isDemolished), 0);
  }
  void add_hasWheelContact(bool hasWheelContact) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_HASWHEELCONTACT, static_cast<uint8_t>(hasWheelContact), 0);
  }
  void add_isSupersonic(bool isSupersonic) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_ISSUPERSONIC, static_cast<uint8_t>(isSupersonic), 0);
  }
  void add_isBot(bool isBot) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_ISBOT, static_cast<uint8_t>(isBot), 0);
  }
  void add_jumped(bool jumped) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_JUMPED, static_cast<uint8_t>(jumped), 0);
  }
  void add_doubleJumped(bool doubleJumped) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_DOUBLEJUMPED, static_cast<uint8_t>(doubleJumped), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlayerInfo::VT_NAME, name);
  }
  void add_team(int32_t team) {
    fbb_.AddElement<int32_t>(PlayerInfo::VT_TEAM, team, 0);
  }
  void add_boost(int32_t boost) {
    fbb_.AddElement<int32_t>(PlayerInfo::VT_BOOST, boost, 0);
  }
  explicit PlayerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerInfoBuilder &operator=(const PlayerInfoBuilder &);
  flatbuffers::Offset<PlayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Physics> physics = 0,
    flatbuffers::Offset<ScoreInfo> scoreInfo = 0,
    bool isDemolished = false,
    bool hasWheelContact = false,
    bool isSupersonic = false,
    bool isBot = false,
    bool jumped = false,
    bool doubleJumped = false,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t team = 0,
    int32_t boost = 0) {
  PlayerInfoBuilder builder_(_fbb);
  builder_.add_boost(boost);
  builder_.add_team(team);
  builder_.add_name(name);
  builder_.add_scoreInfo(scoreInfo);
  builder_.add_physics(physics);
  builder_.add_doubleJumped(doubleJumped);
  builder_.add_jumped(jumped);
  builder_.add_isBot(isBot);
  builder_.add_isSupersonic(isSupersonic);
  builder_.add_hasWheelContact(hasWheelContact);
  builder_.add_isDemolished(isDemolished);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Physics> physics = 0,
    flatbuffers::Offset<ScoreInfo> scoreInfo = 0,
    bool isDemolished = false,
    bool hasWheelContact = false,
    bool isSupersonic = false,
    bool isBot = false,
    bool jumped = false,
    bool doubleJumped = false,
    const char *name = nullptr,
    int32_t team = 0,
    int32_t boost = 0) {
  return rlbot::flat::CreatePlayerInfo(
      _fbb,
      physics,
      scoreInfo,
      isDemolished,
      hasWheelContact,
      isSupersonic,
      isBot,
      jumped,
      doubleJumped,
      name ? _fbb.CreateString(name) : 0,
      team,
      boost);
}

struct DropShotBallInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ABSORBEDFORCE = 4,
    VT_DAMAGEINDEX = 6,
    VT_FORCEACCUMRECENT = 8
  };
  float absorbedForce() const {
    return GetField<float>(VT_ABSORBEDFORCE, 0.0f);
  }
  int32_t damageIndex() const {
    return GetField<int32_t>(VT_DAMAGEINDEX, 0);
  }
  float forceAccumRecent() const {
    return GetField<float>(VT_FORCEACCUMRECENT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ABSORBEDFORCE) &&
           VerifyField<int32_t>(verifier, VT_DAMAGEINDEX) &&
           VerifyField<float>(verifier, VT_FORCEACCUMRECENT) &&
           verifier.EndTable();
  }
};

struct DropShotBallInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_absorbedForce(float absorbedForce) {
    fbb_.AddElement<float>(DropShotBallInfo::VT_ABSORBEDFORCE, absorbedForce, 0.0f);
  }
  void add_damageIndex(int32_t damageIndex) {
    fbb_.AddElement<int32_t>(DropShotBallInfo::VT_DAMAGEINDEX, damageIndex, 0);
  }
  void add_forceAccumRecent(float forceAccumRecent) {
    fbb_.AddElement<float>(DropShotBallInfo::VT_FORCEACCUMRECENT, forceAccumRecent, 0.0f);
  }
  explicit DropShotBallInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropShotBallInfoBuilder &operator=(const DropShotBallInfoBuilder &);
  flatbuffers::Offset<DropShotBallInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropShotBallInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropShotBallInfo> CreateDropShotBallInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float absorbedForce = 0.0f,
    int32_t damageIndex = 0,
    float forceAccumRecent = 0.0f) {
  DropShotBallInfoBuilder builder_(_fbb);
  builder_.add_forceAccumRecent(forceAccumRecent);
  builder_.add_damageIndex(damageIndex);
  builder_.add_absorbedForce(absorbedForce);
  return builder_.Finish();
}

struct BallInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PHYSICS = 4,
    VT_LATESTTOUCH = 6,
    VT_DROPSHOTINFO = 8
  };
  const Physics *physics() const {
    return GetPointer<const Physics *>(VT_PHYSICS);
  }
  const Touch *latestTouch() const {
    return GetPointer<const Touch *>(VT_LATESTTOUCH);
  }
  const DropShotBallInfo *dropShotInfo() const {
    return GetPointer<const DropShotBallInfo *>(VT_DROPSHOTINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           VerifyOffset(verifier, VT_LATESTTOUCH) &&
           verifier.VerifyTable(latestTouch()) &&
           VerifyOffset(verifier, VT_DROPSHOTINFO) &&
           verifier.VerifyTable(dropShotInfo()) &&
           verifier.EndTable();
  }
};

struct BallInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physics(flatbuffers::Offset<Physics> physics) {
    fbb_.AddOffset(BallInfo::VT_PHYSICS, physics);
  }
  void add_latestTouch(flatbuffers::Offset<Touch> latestTouch) {
    fbb_.AddOffset(BallInfo::VT_LATESTTOUCH, latestTouch);
  }
  void add_dropShotInfo(flatbuffers::Offset<DropShotBallInfo> dropShotInfo) {
    fbb_.AddOffset(BallInfo::VT_DROPSHOTINFO, dropShotInfo);
  }
  explicit BallInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BallInfoBuilder &operator=(const BallInfoBuilder &);
  flatbuffers::Offset<BallInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BallInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BallInfo> CreateBallInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Physics> physics = 0,
    flatbuffers::Offset<Touch> latestTouch = 0,
    flatbuffers::Offset<DropShotBallInfo> dropShotInfo = 0) {
  BallInfoBuilder builder_(_fbb);
  builder_.add_dropShotInfo(dropShotInfo);
  builder_.add_latestTouch(latestTouch);
  builder_.add_physics(physics);
  return builder_.Finish();
}

struct BoostPadState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISACTIVE = 4,
    VT_TIMER = 6
  };
  /// True if the boost can be picked up
  bool isActive() const {
    return GetField<uint8_t>(VT_ISACTIVE, 0) != 0;
  }
  /// The number of seconds since the boost has been picked up, or 0.0 if the boost is active.
  float timer() const {
    return GetField<float>(VT_TIMER, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISACTIVE) &&
           VerifyField<float>(verifier, VT_TIMER) &&
           verifier.EndTable();
  }
};

struct BoostPadStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isActive(bool isActive) {
    fbb_.AddElement<uint8_t>(BoostPadState::VT_ISACTIVE, static_cast<uint8_t>(isActive), 0);
  }
  void add_timer(float timer) {
    fbb_.AddElement<float>(BoostPadState::VT_TIMER, timer, 0.0f);
  }
  explicit BoostPadStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoostPadStateBuilder &operator=(const BoostPadStateBuilder &);
  flatbuffers::Offset<BoostPadState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoostPadState>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoostPadState> CreateBoostPadState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool isActive = false,
    float timer = 0.0f) {
  BoostPadStateBuilder builder_(_fbb);
  builder_.add_timer(timer);
  builder_.add_isActive(isActive);
  return builder_.Finish();
}

struct DropshotTile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TILESTATE = 4
  };
  /// True if the tile is damaged
  TileState tileState() const {
    return static_cast<TileState>(GetField<int8_t>(VT_TILESTATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TILESTATE) &&
           verifier.EndTable();
  }
};

struct DropshotTileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tileState(TileState tileState) {
    fbb_.AddElement<int8_t>(DropshotTile::VT_TILESTATE, static_cast<int8_t>(tileState), 0);
  }
  explicit DropshotTileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropshotTileBuilder &operator=(const DropshotTileBuilder &);
  flatbuffers::Offset<DropshotTile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropshotTile>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropshotTile> CreateDropshotTile(
    flatbuffers::FlatBufferBuilder &_fbb,
    TileState tileState = TileState_Unknown) {
  DropshotTileBuilder builder_(_fbb);
  builder_.add_tileState(tileState);
  return builder_.Finish();
}

struct GameInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SECONDSELAPSED = 4,
    VT_GAMETIMEREMAINING = 6,
    VT_ISOVERTIME = 8,
    VT_ISUNLIMITEDTIME = 10,
    VT_ISROUNDACTIVE = 12,
    VT_ISKICKOFFPAUSE = 14,
    VT_ISMATCHENDED = 16,
    VT_WORLDGRAVITYZ = 18
  };
  float secondsElapsed() const {
    return GetField<float>(VT_SECONDSELAPSED, 0.0f);
  }
  float gameTimeRemaining() const {
    return GetField<float>(VT_GAMETIMEREMAINING, 0.0f);
  }
  bool isOvertime() const {
    return GetField<uint8_t>(VT_ISOVERTIME, 0) != 0;
  }
  bool isUnlimitedTime() const {
    return GetField<uint8_t>(VT_ISUNLIMITEDTIME, 0) != 0;
  }
  /// True when cars are allowed to move, and during the pause menu. False during replays.
  bool isRoundActive() const {
    return GetField<uint8_t>(VT_ISROUNDACTIVE, 0) != 0;
  }
  /// Only true during a kickoff, when the car is allowed to move, and the ball has not been hit,
  /// and the game clock has not started yet. If both players sit still, game clock will eventually
  /// start and this will become false.
  bool isKickoffPause() const {
    return GetField<uint8_t>(VT_ISKICKOFFPAUSE, 0) != 0;
  }
  /// Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
  /// countdown. Turns false again the moment the 'choose team' screen appears.
  bool isMatchEnded() const {
    return GetField<uint8_t>(VT_ISMATCHENDED, 0) != 0;
  }
  float worldGravityZ() const {
    return GetField<float>(VT_WORLDGRAVITYZ, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SECONDSELAPSED) &&
           VerifyField<float>(verifier, VT_GAMETIMEREMAINING) &&
           VerifyField<uint8_t>(verifier, VT_ISOVERTIME) &&
           VerifyField<uint8_t>(verifier, VT_ISUNLIMITEDTIME) &&
           VerifyField<uint8_t>(verifier, VT_ISROUNDACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_ISKICKOFFPAUSE) &&
           VerifyField<uint8_t>(verifier, VT_ISMATCHENDED) &&
           VerifyField<float>(verifier, VT_WORLDGRAVITYZ) &&
           verifier.EndTable();
  }
};

struct GameInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_secondsElapsed(float secondsElapsed) {
    fbb_.AddElement<float>(GameInfo::VT_SECONDSELAPSED, secondsElapsed, 0.0f);
  }
  void add_gameTimeRemaining(float gameTimeRemaining) {
    fbb_.AddElement<float>(GameInfo::VT_GAMETIMEREMAINING, gameTimeRemaining, 0.0f);
  }
  void add_isOvertime(bool isOvertime) {
    fbb_.AddElement<uint8_t>(GameInfo::VT_ISOVERTIME, static_cast<uint8_t>(isOvertime), 0);
  }
  void add_isUnlimitedTime(bool isUnlimitedTime) {
    fbb_.AddElement<uint8_t>(GameInfo::VT_ISUNLIMITEDTIME, static_cast<uint8_t>(isUnlimitedTime), 0);
  }
  void add_isRoundActive(bool isRoundActive) {
    fbb_.AddElement<uint8_t>(GameInfo::VT_ISROUNDACTIVE, static_cast<uint8_t>(isRoundActive), 0);
  }
  void add_isKickoffPause(bool isKickoffPause) {
    fbb_.AddElement<uint8_t>(GameInfo::VT_ISKICKOFFPAUSE, static_cast<uint8_t>(isKickoffPause), 0);
  }
  void add_isMatchEnded(bool isMatchEnded) {
    fbb_.AddElement<uint8_t>(GameInfo::VT_ISMATCHENDED, static_cast<uint8_t>(isMatchEnded), 0);
  }
  void add_worldGravityZ(float worldGravityZ) {
    fbb_.AddElement<float>(GameInfo::VT_WORLDGRAVITYZ, worldGravityZ, 0.0f);
  }
  explicit GameInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameInfoBuilder &operator=(const GameInfoBuilder &);
  flatbuffers::Offset<GameInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameInfo> CreateGameInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float secondsElapsed = 0.0f,
    float gameTimeRemaining = 0.0f,
    bool isOvertime = false,
    bool isUnlimitedTime = false,
    bool isRoundActive = false,
    bool isKickoffPause = false,
    bool isMatchEnded = false,
    float worldGravityZ = 0.0f) {
  GameInfoBuilder builder_(_fbb);
  builder_.add_worldGravityZ(worldGravityZ);
  builder_.add_gameTimeRemaining(gameTimeRemaining);
  builder_.add_secondsElapsed(secondsElapsed);
  builder_.add_isMatchEnded(isMatchEnded);
  builder_.add_isKickoffPause(isKickoffPause);
  builder_.add_isRoundActive(isRoundActive);
  builder_.add_isUnlimitedTime(isUnlimitedTime);
  builder_.add_isOvertime(isOvertime);
  return builder_.Finish();
}

struct GameTickPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERS = 4,
    VT_BOOSTPADSTATES = 6,
    VT_BALL = 8,
    VT_GAMEINFO = 10,
    VT_TILEINFORMATION = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>> *>(VT_PLAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BoostPadState>> *boostPadStates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BoostPadState>> *>(VT_BOOSTPADSTATES);
  }
  const BallInfo *ball() const {
    return GetPointer<const BallInfo *>(VT_BALL);
  }
  const GameInfo *gameInfo() const {
    return GetPointer<const GameInfo *>(VT_GAMEINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DropshotTile>> *tileInformation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DropshotTile>> *>(VT_TILEINFORMATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           VerifyOffset(verifier, VT_BOOSTPADSTATES) &&
           verifier.Verify(boostPadStates()) &&
           verifier.VerifyVectorOfTables(boostPadStates()) &&
           VerifyOffset(verifier, VT_BALL) &&
           verifier.VerifyTable(ball()) &&
           VerifyOffset(verifier, VT_GAMEINFO) &&
           verifier.VerifyTable(gameInfo()) &&
           VerifyOffset(verifier, VT_TILEINFORMATION) &&
           verifier.Verify(tileInformation()) &&
           verifier.VerifyVectorOfTables(tileInformation()) &&
           verifier.EndTable();
  }
};

struct GameTickPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>>> players) {
    fbb_.AddOffset(GameTickPacket::VT_PLAYERS, players);
  }
  void add_boostPadStates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoostPadState>>> boostPadStates) {
    fbb_.AddOffset(GameTickPacket::VT_BOOSTPADSTATES, boostPadStates);
  }
  void add_ball(flatbuffers::Offset<BallInfo> ball) {
    fbb_.AddOffset(GameTickPacket::VT_BALL, ball);
  }
  void add_gameInfo(flatbuffers::Offset<GameInfo> gameInfo) {
    fbb_.AddOffset(GameTickPacket::VT_GAMEINFO, gameInfo);
  }
  void add_tileInformation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DropshotTile>>> tileInformation) {
    fbb_.AddOffset(GameTickPacket::VT_TILEINFORMATION, tileInformation);
  }
  explicit GameTickPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameTickPacketBuilder &operator=(const GameTickPacketBuilder &);
  flatbuffers::Offset<GameTickPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameTickPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameTickPacket> CreateGameTickPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>>> players = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoostPadState>>> boostPadStates = 0,
    flatbuffers::Offset<BallInfo> ball = 0,
    flatbuffers::Offset<GameInfo> gameInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DropshotTile>>> tileInformation = 0) {
  GameTickPacketBuilder builder_(_fbb);
  builder_.add_tileInformation(tileInformation);
  builder_.add_gameInfo(gameInfo);
  builder_.add_ball(ball);
  builder_.add_boostPadStates(boostPadStates);
  builder_.add_players(players);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameTickPacket> CreateGameTickPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PlayerInfo>> *players = nullptr,
    const std::vector<flatbuffers::Offset<BoostPadState>> *boostPadStates = nullptr,
    flatbuffers::Offset<BallInfo> ball = 0,
    flatbuffers::Offset<GameInfo> gameInfo = 0,
    const std::vector<flatbuffers::Offset<DropshotTile>> *tileInformation = nullptr) {
  return rlbot::flat::CreateGameTickPacket(
      _fbb,
      players ? _fbb.CreateVector<flatbuffers::Offset<PlayerInfo>>(*players) : 0,
      boostPadStates ? _fbb.CreateVector<flatbuffers::Offset<BoostPadState>>(*boostPadStates) : 0,
      ball,
      gameInfo,
      tileInformation ? _fbb.CreateVector<flatbuffers::Offset<DropshotTile>>(*tileInformation) : 0);
}

/// The state of a rigid body in Rocket League's physics engine.
/// This gets updated in time with the physics tick, not the rendering framerate.
/// The frame field will be incremented every time the physics engine ticks.
struct RigidBodyState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_LOCATION = 6,
    VT_ROTATION = 8,
    VT_VELOCITY = 10,
    VT_ANGULARVELOCITY = 12
  };
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  const Quaternion *rotation() const {
    return GetStruct<const Quaternion *>(VT_ROTATION);
  }
  const Vector3 *velocity() const {
    return GetStruct<const Vector3 *>(VT_VELOCITY);
  }
  const Vector3 *angularVelocity() const {
    return GetStruct<const Vector3 *>(VT_ANGULARVELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Quaternion>(verifier, VT_ROTATION) &&
           VerifyField<Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<Vector3>(verifier, VT_ANGULARVELOCITY) &&
           verifier.EndTable();
  }
};

struct RigidBodyStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(RigidBodyState::VT_FRAME, frame, 0);
  }
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(RigidBodyState::VT_LOCATION, location);
  }
  void add_rotation(const Quaternion *rotation) {
    fbb_.AddStruct(RigidBodyState::VT_ROTATION, rotation);
  }
  void add_velocity(const Vector3 *velocity) {
    fbb_.AddStruct(RigidBodyState::VT_VELOCITY, velocity);
  }
  void add_angularVelocity(const Vector3 *angularVelocity) {
    fbb_.AddStruct(RigidBodyState::VT_ANGULARVELOCITY, angularVelocity);
  }
  explicit RigidBodyStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RigidBodyStateBuilder &operator=(const RigidBodyStateBuilder &);
  flatbuffers::Offset<RigidBodyState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RigidBodyState>(end);
    return o;
  }
};

inline flatbuffers::Offset<RigidBodyState> CreateRigidBodyState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame = 0,
    const Vector3 *location = 0,
    const Quaternion *rotation = 0,
    const Vector3 *velocity = 0,
    const Vector3 *angularVelocity = 0) {
  RigidBodyStateBuilder builder_(_fbb);
  builder_.add_angularVelocity(angularVelocity);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_location(location);
  builder_.add_frame(frame);
  return builder_.Finish();
}

/// Rigid body state for a player / car in the game. Includes the latest
/// controller input, which is otherwise difficult to correlate with consequences.
struct PlayerRigidBodyState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_INPUT = 6
  };
  const RigidBodyState *state() const {
    return GetPointer<const RigidBodyState *>(VT_STATE);
  }
  const ControllerState *input() const {
    return GetPointer<const ControllerState *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           verifier.EndTable();
  }
};

struct PlayerRigidBodyStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(flatbuffers::Offset<RigidBodyState> state) {
    fbb_.AddOffset(PlayerRigidBodyState::VT_STATE, state);
  }
  void add_input(flatbuffers::Offset<ControllerState> input) {
    fbb_.AddOffset(PlayerRigidBodyState::VT_INPUT, input);
  }
  explicit PlayerRigidBodyStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerRigidBodyStateBuilder &operator=(const PlayerRigidBodyStateBuilder &);
  flatbuffers::Offset<PlayerRigidBodyState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerRigidBodyState>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerRigidBodyState> CreatePlayerRigidBodyState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RigidBodyState> state = 0,
    flatbuffers::Offset<ControllerState> input = 0) {
  PlayerRigidBodyStateBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_state(state);
  return builder_.Finish();
}

/// Rigid body state for the ball.
struct BallRigidBodyState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  const RigidBodyState *state() const {
    return GetPointer<const RigidBodyState *>(VT_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           verifier.EndTable();
  }
};

struct BallRigidBodyStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(flatbuffers::Offset<RigidBodyState> state) {
    fbb_.AddOffset(BallRigidBodyState::VT_STATE, state);
  }
  explicit BallRigidBodyStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BallRigidBodyStateBuilder &operator=(const BallRigidBodyStateBuilder &);
  flatbuffers::Offset<BallRigidBodyState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BallRigidBodyState>(end);
    return o;
  }
};

inline flatbuffers::Offset<BallRigidBodyState> CreateBallRigidBodyState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RigidBodyState> state = 0) {
  BallRigidBodyStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

/// Contains all rigid body state information.
struct RigidBodyTick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BALL = 4,
    VT_PLAYERS = 6
  };
  const BallRigidBodyState *ball() const {
    return GetPointer<const BallRigidBodyState *>(VT_BALL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PlayerRigidBodyState>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerRigidBodyState>> *>(VT_PLAYERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BALL) &&
           verifier.VerifyTable(ball()) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           verifier.EndTable();
  }
};

struct RigidBodyTickBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ball(flatbuffers::Offset<BallRigidBodyState> ball) {
    fbb_.AddOffset(RigidBodyTick::VT_BALL, ball);
  }
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerRigidBodyState>>> players) {
    fbb_.AddOffset(RigidBodyTick::VT_PLAYERS, players);
  }
  explicit RigidBodyTickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RigidBodyTickBuilder &operator=(const RigidBodyTickBuilder &);
  flatbuffers::Offset<RigidBodyTick> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RigidBodyTick>(end);
    return o;
  }
};

inline flatbuffers::Offset<RigidBodyTick> CreateRigidBodyTick(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BallRigidBodyState> ball = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerRigidBodyState>>> players = 0) {
  RigidBodyTickBuilder builder_(_fbb);
  builder_.add_players(players);
  builder_.add_ball(ball);
  return builder_.Finish();
}

inline flatbuffers::Offset<RigidBodyTick> CreateRigidBodyTickDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BallRigidBodyState> ball = 0,
    const std::vector<flatbuffers::Offset<PlayerRigidBodyState>> *players = nullptr) {
  return rlbot::flat::CreateRigidBodyTick(
      _fbb,
      ball,
      players ? _fbb.CreateVector<flatbuffers::Offset<PlayerRigidBodyState>>(*players) : 0);
}

struct GoalInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEAMNUM = 4,
    VT_LOCATION = 6,
    VT_DIRECTION = 8
  };
  int32_t teamNum() const {
    return GetField<int32_t>(VT_TEAMNUM, 0);
  }
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  const Vector3 *direction() const {
    return GetStruct<const Vector3 *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEAMNUM) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Vector3>(verifier, VT_DIRECTION) &&
           verifier.EndTable();
  }
};

struct GoalInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_teamNum(int32_t teamNum) {
    fbb_.AddElement<int32_t>(GoalInfo::VT_TEAMNUM, teamNum, 0);
  }
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(GoalInfo::VT_LOCATION, location);
  }
  void add_direction(const Vector3 *direction) {
    fbb_.AddStruct(GoalInfo::VT_DIRECTION, direction);
  }
  explicit GoalInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GoalInfoBuilder &operator=(const GoalInfoBuilder &);
  flatbuffers::Offset<GoalInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GoalInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GoalInfo> CreateGoalInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t teamNum = 0,
    const Vector3 *location = 0,
    const Vector3 *direction = 0) {
  GoalInfoBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_teamNum(teamNum);
  return builder_.Finish();
}

struct BoostPad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOCATION = 4,
    VT_ISFULLBOOST = 6
  };
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  bool isFullBoost() const {
    return GetField<uint8_t>(VT_ISFULLBOOST, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<uint8_t>(verifier, VT_ISFULLBOOST) &&
           verifier.EndTable();
  }
};

struct BoostPadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(BoostPad::VT_LOCATION, location);
  }
  void add_isFullBoost(bool isFullBoost) {
    fbb_.AddElement<uint8_t>(BoostPad::VT_ISFULLBOOST, static_cast<uint8_t>(isFullBoost), 0);
  }
  explicit BoostPadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoostPadBuilder &operator=(const BoostPadBuilder &);
  flatbuffers::Offset<BoostPad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoostPad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoostPad> CreateBoostPad(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3 *location = 0,
    bool isFullBoost = false) {
  BoostPadBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_isFullBoost(isFullBoost);
  return builder_.Finish();
}

struct FieldInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BOOSTPADS = 4,
    VT_GOALS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<BoostPad>> *boostPads() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BoostPad>> *>(VT_BOOSTPADS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GoalInfo>> *goals() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GoalInfo>> *>(VT_GOALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOOSTPADS) &&
           verifier.Verify(boostPads()) &&
           verifier.VerifyVectorOfTables(boostPads()) &&
           VerifyOffset(verifier, VT_GOALS) &&
           verifier.Verify(goals()) &&
           verifier.VerifyVectorOfTables(goals()) &&
           verifier.EndTable();
  }
};

struct FieldInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boostPads(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoostPad>>> boostPads) {
    fbb_.AddOffset(FieldInfo::VT_BOOSTPADS, boostPads);
  }
  void add_goals(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GoalInfo>>> goals) {
    fbb_.AddOffset(FieldInfo::VT_GOALS, goals);
  }
  explicit FieldInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldInfoBuilder &operator=(const FieldInfoBuilder &);
  flatbuffers::Offset<FieldInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldInfo> CreateFieldInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoostPad>>> boostPads = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GoalInfo>>> goals = 0) {
  FieldInfoBuilder builder_(_fbb);
  builder_.add_goals(goals);
  builder_.add_boostPads(boostPads);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldInfo> CreateFieldInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BoostPad>> *boostPads = nullptr,
    const std::vector<flatbuffers::Offset<GoalInfo>> *goals = nullptr) {
  return rlbot::flat::CreateFieldInfo(
      _fbb,
      boostPads ? _fbb.CreateVector<flatbuffers::Offset<BoostPad>>(*boostPads) : 0,
      goals ? _fbb.CreateVector<flatbuffers::Offset<GoalInfo>>(*goals) : 0);
}

struct Vector3Partial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  const Float *x() const {
    return GetStruct<const Float *>(VT_X);
  }
  const Float *y() const {
    return GetStruct<const Float *>(VT_Y);
  }
  const Float *z() const {
    return GetStruct<const Float *>(VT_Z);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Float>(verifier, VT_X) &&
           VerifyField<Float>(verifier, VT_Y) &&
           VerifyField<Float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct Vector3PartialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(const Float *x) {
    fbb_.AddStruct(Vector3Partial::VT_X, x);
  }
  void add_y(const Float *y) {
    fbb_.AddStruct(Vector3Partial::VT_Y, y);
  }
  void add_z(const Float *z) {
    fbb_.AddStruct(Vector3Partial::VT_Z, z);
  }
  explicit Vector3PartialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vector3PartialBuilder &operator=(const Vector3PartialBuilder &);
  flatbuffers::Offset<Vector3Partial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3Partial>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3Partial> CreateVector3Partial(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Float *x = 0,
    const Float *y = 0,
    const Float *z = 0) {
  Vector3PartialBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct RotatorPartial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PITCH = 4,
    VT_YAW = 6,
    VT_ROLL = 8
  };
  const Float *pitch() const {
    return GetStruct<const Float *>(VT_PITCH);
  }
  const Float *yaw() const {
    return GetStruct<const Float *>(VT_YAW);
  }
  const Float *roll() const {
    return GetStruct<const Float *>(VT_ROLL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Float>(verifier, VT_PITCH) &&
           VerifyField<Float>(verifier, VT_YAW) &&
           VerifyField<Float>(verifier, VT_ROLL) &&
           verifier.EndTable();
  }
};

struct RotatorPartialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pitch(const Float *pitch) {
    fbb_.AddStruct(RotatorPartial::VT_PITCH, pitch);
  }
  void add_yaw(const Float *yaw) {
    fbb_.AddStruct(RotatorPartial::VT_YAW, yaw);
  }
  void add_roll(const Float *roll) {
    fbb_.AddStruct(RotatorPartial::VT_ROLL, roll);
  }
  explicit RotatorPartialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RotatorPartialBuilder &operator=(const RotatorPartialBuilder &);
  flatbuffers::Offset<RotatorPartial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RotatorPartial>(end);
    return o;
  }
};

inline flatbuffers::Offset<RotatorPartial> CreateRotatorPartial(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Float *pitch = 0,
    const Float *yaw = 0,
    const Float *roll = 0) {
  RotatorPartialBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  return builder_.Finish();
}

struct DesiredPhysics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOCATION = 4,
    VT_ROTATION = 6,
    VT_VELOCITY = 8,
    VT_ANGULARVELOCITY = 10
  };
  const Vector3Partial *location() const {
    return GetPointer<const Vector3Partial *>(VT_LOCATION);
  }
  const RotatorPartial *rotation() const {
    return GetPointer<const RotatorPartial *>(VT_ROTATION);
  }
  const Vector3Partial *velocity() const {
    return GetPointer<const Vector3Partial *>(VT_VELOCITY);
  }
  const Vector3Partial *angularVelocity() const {
    return GetPointer<const Vector3Partial *>(VT_ANGULARVELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           VerifyOffset(verifier, VT_ANGULARVELOCITY) &&
           verifier.VerifyTable(angularVelocity()) &&
           verifier.EndTable();
  }
};

struct DesiredPhysicsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(flatbuffers::Offset<Vector3Partial> location) {
    fbb_.AddOffset(DesiredPhysics::VT_LOCATION, location);
  }
  void add_rotation(flatbuffers::Offset<RotatorPartial> rotation) {
    fbb_.AddOffset(DesiredPhysics::VT_ROTATION, rotation);
  }
  void add_velocity(flatbuffers::Offset<Vector3Partial> velocity) {
    fbb_.AddOffset(DesiredPhysics::VT_VELOCITY, velocity);
  }
  void add_angularVelocity(flatbuffers::Offset<Vector3Partial> angularVelocity) {
    fbb_.AddOffset(DesiredPhysics::VT_ANGULARVELOCITY, angularVelocity);
  }
  explicit DesiredPhysicsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredPhysicsBuilder &operator=(const DesiredPhysicsBuilder &);
  flatbuffers::Offset<DesiredPhysics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredPhysics>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredPhysics> CreateDesiredPhysics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vector3Partial> location = 0,
    flatbuffers::Offset<RotatorPartial> rotation = 0,
    flatbuffers::Offset<Vector3Partial> velocity = 0,
    flatbuffers::Offset<Vector3Partial> angularVelocity = 0) {
  DesiredPhysicsBuilder builder_(_fbb);
  builder_.add_angularVelocity(angularVelocity);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_location(location);
  return builder_.Finish();
}

struct DesiredBallState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PHYSICS = 4
  };
  const DesiredPhysics *physics() const {
    return GetPointer<const DesiredPhysics *>(VT_PHYSICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           verifier.EndTable();
  }
};

struct DesiredBallStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physics(flatbuffers::Offset<DesiredPhysics> physics) {
    fbb_.AddOffset(DesiredBallState::VT_PHYSICS, physics);
  }
  explicit DesiredBallStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredBallStateBuilder &operator=(const DesiredBallStateBuilder &);
  flatbuffers::Offset<DesiredBallState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredBallState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredBallState> CreateDesiredBallState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DesiredPhysics> physics = 0) {
  DesiredBallStateBuilder builder_(_fbb);
  builder_.add_physics(physics);
  return builder_.Finish();
}

struct DesiredCarState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PHYSICS = 4,
    VT_BOOSTAMOUNT = 6,
    VT_JUMPED = 8,
    VT_DOUBLEJUMPED = 10
  };
  const DesiredPhysics *physics() const {
    return GetPointer<const DesiredPhysics *>(VT_PHYSICS);
  }
  const Float *boostAmount() const {
    return GetStruct<const Float *>(VT_BOOSTAMOUNT);
  }
  const Bool *jumped() const {
    return GetStruct<const Bool *>(VT_JUMPED);
  }
  const Bool *doubleJumped() const {
    return GetStruct<const Bool *>(VT_DOUBLEJUMPED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           VerifyField<Float>(verifier, VT_BOOSTAMOUNT) &&
           VerifyField<Bool>(verifier, VT_JUMPED) &&
           VerifyField<Bool>(verifier, VT_DOUBLEJUMPED) &&
           verifier.EndTable();
  }
};

struct DesiredCarStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physics(flatbuffers::Offset<DesiredPhysics> physics) {
    fbb_.AddOffset(DesiredCarState::VT_PHYSICS, physics);
  }
  void add_boostAmount(const Float *boostAmount) {
    fbb_.AddStruct(DesiredCarState::VT_BOOSTAMOUNT, boostAmount);
  }
  void add_jumped(const Bool *jumped) {
    fbb_.AddStruct(DesiredCarState::VT_JUMPED, jumped);
  }
  void add_doubleJumped(const Bool *doubleJumped) {
    fbb_.AddStruct(DesiredCarState::VT_DOUBLEJUMPED, doubleJumped);
  }
  explicit DesiredCarStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredCarStateBuilder &operator=(const DesiredCarStateBuilder &);
  flatbuffers::Offset<DesiredCarState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredCarState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredCarState> CreateDesiredCarState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DesiredPhysics> physics = 0,
    const Float *boostAmount = 0,
    const Bool *jumped = 0,
    const Bool *doubleJumped = 0) {
  DesiredCarStateBuilder builder_(_fbb);
  builder_.add_doubleJumped(doubleJumped);
  builder_.add_jumped(jumped);
  builder_.add_boostAmount(boostAmount);
  builder_.add_physics(physics);
  return builder_.Finish();
}

struct DesiredBoostState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPAWNTIME = 4
  };
  const Float *respawnTime() const {
    return GetStruct<const Float *>(VT_RESPAWNTIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Float>(verifier, VT_RESPAWNTIME) &&
           verifier.EndTable();
  }
};

struct DesiredBoostStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_respawnTime(const Float *respawnTime) {
    fbb_.AddStruct(DesiredBoostState::VT_RESPAWNTIME, respawnTime);
  }
  explicit DesiredBoostStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredBoostStateBuilder &operator=(const DesiredBoostStateBuilder &);
  flatbuffers::Offset<DesiredBoostState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredBoostState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredBoostState> CreateDesiredBoostState(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Float *respawnTime = 0) {
  DesiredBoostStateBuilder builder_(_fbb);
  builder_.add_respawnTime(respawnTime);
  return builder_.Finish();
}

struct DesiredGameInfoState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WORLDGRAVITYZ = 4
  };
  const Float *worldGravityZ() const {
    return GetStruct<const Float *>(VT_WORLDGRAVITYZ);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Float>(verifier, VT_WORLDGRAVITYZ) &&
           verifier.EndTable();
  }
};

struct DesiredGameInfoStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_worldGravityZ(const Float *worldGravityZ) {
    fbb_.AddStruct(DesiredGameInfoState::VT_WORLDGRAVITYZ, worldGravityZ);
  }
  explicit DesiredGameInfoStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredGameInfoStateBuilder &operator=(const DesiredGameInfoStateBuilder &);
  flatbuffers::Offset<DesiredGameInfoState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredGameInfoState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredGameInfoState> CreateDesiredGameInfoState(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Float *worldGravityZ = 0) {
  DesiredGameInfoStateBuilder builder_(_fbb);
  builder_.add_worldGravityZ(worldGravityZ);
  return builder_.Finish();
}

struct DesiredGameState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BALLSTATE = 4,
    VT_CARSTATES = 6,
    VT_BOOSTSTATES = 8,
    VT_GAMEINFOSTATE = 10
  };
  const DesiredBallState *ballState() const {
    return GetPointer<const DesiredBallState *>(VT_BALLSTATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DesiredCarState>> *carStates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DesiredCarState>> *>(VT_CARSTATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DesiredBoostState>> *boostStates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DesiredBoostState>> *>(VT_BOOSTSTATES);
  }
  const DesiredGameInfoState *gameInfoState() const {
    return GetPointer<const DesiredGameInfoState *>(VT_GAMEINFOSTATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BALLSTATE) &&
           verifier.VerifyTable(ballState()) &&
           VerifyOffset(verifier, VT_CARSTATES) &&
           verifier.Verify(carStates()) &&
           verifier.VerifyVectorOfTables(carStates()) &&
           VerifyOffset(verifier, VT_BOOSTSTATES) &&
           verifier.Verify(boostStates()) &&
           verifier.VerifyVectorOfTables(boostStates()) &&
           VerifyOffset(verifier, VT_GAMEINFOSTATE) &&
           verifier.VerifyTable(gameInfoState()) &&
           verifier.EndTable();
  }
};

struct DesiredGameStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ballState(flatbuffers::Offset<DesiredBallState> ballState) {
    fbb_.AddOffset(DesiredGameState::VT_BALLSTATE, ballState);
  }
  void add_carStates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DesiredCarState>>> carStates) {
    fbb_.AddOffset(DesiredGameState::VT_CARSTATES, carStates);
  }
  void add_boostStates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DesiredBoostState>>> boostStates) {
    fbb_.AddOffset(DesiredGameState::VT_BOOSTSTATES, boostStates);
  }
  void add_gameInfoState(flatbuffers::Offset<DesiredGameInfoState> gameInfoState) {
    fbb_.AddOffset(DesiredGameState::VT_GAMEINFOSTATE, gameInfoState);
  }
  explicit DesiredGameStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DesiredGameStateBuilder &operator=(const DesiredGameStateBuilder &);
  flatbuffers::Offset<DesiredGameState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesiredGameState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesiredGameState> CreateDesiredGameState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DesiredBallState> ballState = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DesiredCarState>>> carStates = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DesiredBoostState>>> boostStates = 0,
    flatbuffers::Offset<DesiredGameInfoState> gameInfoState = 0) {
  DesiredGameStateBuilder builder_(_fbb);
  builder_.add_gameInfoState(gameInfoState);
  builder_.add_boostStates(boostStates);
  builder_.add_carStates(carStates);
  builder_.add_ballState(ballState);
  return builder_.Finish();
}

inline flatbuffers::Offset<DesiredGameState> CreateDesiredGameStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DesiredBallState> ballState = 0,
    const std::vector<flatbuffers::Offset<DesiredCarState>> *carStates = nullptr,
    const std::vector<flatbuffers::Offset<DesiredBoostState>> *boostStates = nullptr,
    flatbuffers::Offset<DesiredGameInfoState> gameInfoState = 0) {
  return rlbot::flat::CreateDesiredGameState(
      _fbb,
      ballState,
      carStates ? _fbb.CreateVector<flatbuffers::Offset<DesiredCarState>>(*carStates) : 0,
      boostStates ? _fbb.CreateVector<flatbuffers::Offset<DesiredBoostState>>(*boostStates) : 0,
      gameInfoState);
}

struct Color FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_A = 4,
    VT_R = 6,
    VT_G = 8,
    VT_B = 10
  };
  uint8_t a() const {
    return GetField<uint8_t>(VT_A, 0);
  }
  uint8_t r() const {
    return GetField<uint8_t>(VT_R, 0);
  }
  uint8_t g() const {
    return GetField<uint8_t>(VT_G, 0);
  }
  uint8_t b() const {
    return GetField<uint8_t>(VT_B, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_A) &&
           VerifyField<uint8_t>(verifier, VT_R) &&
           VerifyField<uint8_t>(verifier, VT_G) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           verifier.EndTable();
  }
};

struct ColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(uint8_t a) {
    fbb_.AddElement<uint8_t>(Color::VT_A, a, 0);
  }
  void add_r(uint8_t r) {
    fbb_.AddElement<uint8_t>(Color::VT_R, r, 0);
  }
  void add_g(uint8_t g) {
    fbb_.AddElement<uint8_t>(Color::VT_G, g, 0);
  }
  void add_b(uint8_t b) {
    fbb_.AddElement<uint8_t>(Color::VT_B, b, 0);
  }
  explicit ColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColorBuilder &operator=(const ColorBuilder &);
  flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline flatbuffers::Offset<Color> CreateColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t a = 0,
    uint8_t r = 0,
    uint8_t g = 0,
    uint8_t b = 0) {
  ColorBuilder builder_(_fbb);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  builder_.add_a(a);
  return builder_.Finish();
}

struct RenderMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RENDERTYPE = 4,
    VT_COLOR = 6,
    VT_START = 8,
    VT_END = 10,
    VT_SCALEX = 12,
    VT_SCALEY = 14,
    VT_TEXT = 16,
    VT_ISFILLED = 18
  };
  RenderType renderType() const {
    return static_cast<RenderType>(GetField<int8_t>(VT_RENDERTYPE, 1));
  }
  const Color *color() const {
    return GetPointer<const Color *>(VT_COLOR);
  }
  /// For 2d renders this only grabs x and y
  const Vector3 *start() const {
    return GetStruct<const Vector3 *>(VT_START);
  }
  /// For 2d renders this only grabs x and y
  const Vector3 *end() const {
    return GetStruct<const Vector3 *>(VT_END);
  }
  /// Scales the x size of the text/rectangle, is used for rectangles assuming an initial value of 1
  int32_t scaleX() const {
    return GetField<int32_t>(VT_SCALEX, 1);
  }
  /// Scales the y size of the text/rectangle, is used for rectangles assuming an initial value of 1
  int32_t scaleY() const {
    return GetField<int32_t>(VT_SCALEY, 1);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  /// Rectangles can be filled or just outlines.
  bool isFilled() const {
    return GetField<uint8_t>(VT_ISFILLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RENDERTYPE) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyField<Vector3>(verifier, VT_START) &&
           VerifyField<Vector3>(verifier, VT_END) &&
           VerifyField<int32_t>(verifier, VT_SCALEX) &&
           VerifyField<int32_t>(verifier, VT_SCALEY) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<uint8_t>(verifier, VT_ISFILLED) &&
           verifier.EndTable();
  }
};

struct RenderMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_renderType(RenderType renderType) {
    fbb_.AddElement<int8_t>(RenderMessage::VT_RENDERTYPE, static_cast<int8_t>(renderType), 1);
  }
  void add_color(flatbuffers::Offset<Color> color) {
    fbb_.AddOffset(RenderMessage::VT_COLOR, color);
  }
  void add_start(const Vector3 *start) {
    fbb_.AddStruct(RenderMessage::VT_START, start);
  }
  void add_end(const Vector3 *end) {
    fbb_.AddStruct(RenderMessage::VT_END, end);
  }
  void add_scaleX(int32_t scaleX) {
    fbb_.AddElement<int32_t>(RenderMessage::VT_SCALEX, scaleX, 1);
  }
  void add_scaleY(int32_t scaleY) {
    fbb_.AddElement<int32_t>(RenderMessage::VT_SCALEY, scaleY, 1);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(RenderMessage::VT_TEXT, text);
  }
  void add_isFilled(bool isFilled) {
    fbb_.AddElement<uint8_t>(RenderMessage::VT_ISFILLED, static_cast<uint8_t>(isFilled), 0);
  }
  explicit RenderMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderMessageBuilder &operator=(const RenderMessageBuilder &);
  flatbuffers::Offset<RenderMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderMessage> CreateRenderMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    RenderType renderType = RenderType_DrawLine2D,
    flatbuffers::Offset<Color> color = 0,
    const Vector3 *start = 0,
    const Vector3 *end = 0,
    int32_t scaleX = 1,
    int32_t scaleY = 1,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    bool isFilled = false) {
  RenderMessageBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_color(color);
  builder_.add_isFilled(isFilled);
  builder_.add_renderType(renderType);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderMessage> CreateRenderMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RenderType renderType = RenderType_DrawLine2D,
    flatbuffers::Offset<Color> color = 0,
    const Vector3 *start = 0,
    const Vector3 *end = 0,
    int32_t scaleX = 1,
    int32_t scaleY = 1,
    const char *text = nullptr,
    bool isFilled = false) {
  return rlbot::flat::CreateRenderMessage(
      _fbb,
      renderType,
      color,
      start,
      end,
      scaleX,
      scaleY,
      text ? _fbb.CreateString(text) : 0,
      isFilled);
}

struct RenderGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RENDERMESSAGES = 4,
    VT_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<RenderMessage>> *renderMessages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RenderMessage>> *>(VT_RENDERMESSAGES);
  }
  /// The id of the render group
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RENDERMESSAGES) &&
           verifier.Verify(renderMessages()) &&
           verifier.VerifyVectorOfTables(renderMessages()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RenderGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_renderMessages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RenderMessage>>> renderMessages) {
    fbb_.AddOffset(RenderGroup::VT_RENDERMESSAGES, renderMessages);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(RenderGroup::VT_ID, id, 0);
  }
  explicit RenderGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderGroupBuilder &operator=(const RenderGroupBuilder &);
  flatbuffers::Offset<RenderGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderGroup> CreateRenderGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RenderMessage>>> renderMessages = 0,
    int32_t id = 0) {
  RenderGroupBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_renderMessages(renderMessages);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderGroup> CreateRenderGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RenderMessage>> *renderMessages = nullptr,
    int32_t id = 0) {
  return rlbot::flat::CreateRenderGroup(
      _fbb,
      renderMessages ? _fbb.CreateVector<flatbuffers::Offset<RenderMessage>>(*renderMessages) : 0,
      id);
}

struct QuickChat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUICKCHATSELECTION = 4,
    VT_PLAYERINDEX = 6,
    VT_TEAMONLY = 8
  };
  QuickChatSelection quickChatSelection() const {
    return static_cast<QuickChatSelection>(GetField<int8_t>(VT_QUICKCHATSELECTION, 0));
  }
  /// The index of the player that sent the quick chat
  int32_t playerIndex() const {
    return GetField<int32_t>(VT_PLAYERINDEX, 0);
  }
  /// True if the chat is team only false if everyone can see it.
  bool teamOnly() const {
    return GetField<uint8_t>(VT_TEAMONLY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_QUICKCHATSELECTION) &&
           VerifyField<int32_t>(verifier, VT_PLAYERINDEX) &&
           VerifyField<uint8_t>(verifier, VT_TEAMONLY) &&
           verifier.EndTable();
  }
};

struct QuickChatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quickChatSelection(QuickChatSelection quickChatSelection) {
    fbb_.AddElement<int8_t>(QuickChat::VT_QUICKCHATSELECTION, static_cast<int8_t>(quickChatSelection), 0);
  }
  void add_playerIndex(int32_t playerIndex) {
    fbb_.AddElement<int32_t>(QuickChat::VT_PLAYERINDEX, playerIndex, 0);
  }
  void add_teamOnly(bool teamOnly) {
    fbb_.AddElement<uint8_t>(QuickChat::VT_TEAMONLY, static_cast<uint8_t>(teamOnly), 0);
  }
  explicit QuickChatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuickChatBuilder &operator=(const QuickChatBuilder &);
  flatbuffers::Offset<QuickChat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuickChat>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuickChat> CreateQuickChat(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuickChatSelection quickChatSelection = QuickChatSelection_Information_IGotIt,
    int32_t playerIndex = 0,
    bool teamOnly = false) {
  QuickChatBuilder builder_(_fbb);
  builder_.add_playerIndex(playerIndex);
  builder_.add_teamOnly(teamOnly);
  builder_.add_quickChatSelection(quickChatSelection);
  return builder_.Finish();
}

/// A minimal version of player data, useful when bandwidth needs to be conserved.
struct TinyPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOCATION = 4,
    VT_ROTATION = 6,
    VT_VELOCITY = 8,
    VT_HASWHEELCONTACT = 10,
    VT_ISSUPERSONIC = 12,
    VT_TEAM = 14,
    VT_BOOST = 16
  };
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  const Rotator *rotation() const {
    return GetStruct<const Rotator *>(VT_ROTATION);
  }
  const Vector3 *velocity() const {
    return GetStruct<const Vector3 *>(VT_VELOCITY);
  }
  bool hasWheelContact() const {
    return GetField<uint8_t>(VT_HASWHEELCONTACT, 0) != 0;
  }
  bool isSupersonic() const {
    return GetField<uint8_t>(VT_ISSUPERSONIC, 0) != 0;
  }
  int32_t team() const {
    return GetField<int32_t>(VT_TEAM, 0);
  }
  int32_t boost() const {
    return GetField<int32_t>(VT_BOOST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Rotator>(verifier, VT_ROTATION) &&
           VerifyField<Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<uint8_t>(verifier, VT_HASWHEELCONTACT) &&
           VerifyField<uint8_t>(verifier, VT_ISSUPERSONIC) &&
           VerifyField<int32_t>(verifier, VT_TEAM) &&
           VerifyField<int32_t>(verifier, VT_BOOST) &&
           verifier.EndTable();
  }
};

struct TinyPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(TinyPlayer::VT_LOCATION, location);
  }
  void add_rotation(const Rotator *rotation) {
    fbb_.AddStruct(TinyPlayer::VT_ROTATION, rotation);
  }
  void add_velocity(const Vector3 *velocity) {
    fbb_.AddStruct(TinyPlayer::VT_VELOCITY, velocity);
  }
  void add_hasWheelContact(bool hasWheelContact) {
    fbb_.AddElement<uint8_t>(TinyPlayer::VT_HASWHEELCONTACT, static_cast<uint8_t>(hasWheelContact), 0);
  }
  void add_isSupersonic(bool isSupersonic) {
    fbb_.AddElement<uint8_t>(TinyPlayer::VT_ISSUPERSONIC, static_cast<uint8_t>(isSupersonic), 0);
  }
  void add_team(int32_t team) {
    fbb_.AddElement<int32_t>(TinyPlayer::VT_TEAM, team, 0);
  }
  void add_boost(int32_t boost) {
    fbb_.AddElement<int32_t>(TinyPlayer::VT_BOOST, boost, 0);
  }
  explicit TinyPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TinyPlayerBuilder &operator=(const TinyPlayerBuilder &);
  flatbuffers::Offset<TinyPlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TinyPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<TinyPlayer> CreateTinyPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3 *location = 0,
    const Rotator *rotation = 0,
    const Vector3 *velocity = 0,
    bool hasWheelContact = false,
    bool isSupersonic = false,
    int32_t team = 0,
    int32_t boost = 0) {
  TinyPlayerBuilder builder_(_fbb);
  builder_.add_boost(boost);
  builder_.add_team(team);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_location(location);
  builder_.add_isSupersonic(isSupersonic);
  builder_.add_hasWheelContact(hasWheelContact);
  return builder_.Finish();
}

/// A minimal version of the ball, useful when bandwidth needs to be conserved.
struct TinyBall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOCATION = 4,
    VT_VELOCITY = 6
  };
  const Vector3 *location() const {
    return GetStruct<const Vector3 *>(VT_LOCATION);
  }
  const Vector3 *velocity() const {
    return GetStruct<const Vector3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, VT_LOCATION) &&
           VerifyField<Vector3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
};

struct TinyBallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(const Vector3 *location) {
    fbb_.AddStruct(TinyBall::VT_LOCATION, location);
  }
  void add_velocity(const Vector3 *velocity) {
    fbb_.AddStruct(TinyBall::VT_VELOCITY, velocity);
  }
  explicit TinyBallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TinyBallBuilder &operator=(const TinyBallBuilder &);
  flatbuffers::Offset<TinyBall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TinyBall>(end);
    return o;
  }
};

inline flatbuffers::Offset<TinyBall> CreateTinyBall(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3 *location = 0,
    const Vector3 *velocity = 0) {
  TinyBallBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_location(location);
  return builder_.Finish();
}

/// A minimal version of the game tick packet, useful when bandwidth needs to be conserved.
struct TinyPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERS = 4,
    VT_BALL = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<TinyPlayer>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TinyPlayer>> *>(VT_PLAYERS);
  }
  const TinyBall *ball() const {
    return GetPointer<const TinyBall *>(VT_BALL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           VerifyOffset(verifier, VT_BALL) &&
           verifier.VerifyTable(ball()) &&
           verifier.EndTable();
  }
};

struct TinyPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TinyPlayer>>> players) {
    fbb_.AddOffset(TinyPacket::VT_PLAYERS, players);
  }
  void add_ball(flatbuffers::Offset<TinyBall> ball) {
    fbb_.AddOffset(TinyPacket::VT_BALL, ball);
  }
  explicit TinyPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TinyPacketBuilder &operator=(const TinyPacketBuilder &);
  flatbuffers::Offset<TinyPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TinyPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<TinyPacket> CreateTinyPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TinyPlayer>>> players = 0,
    flatbuffers::Offset<TinyBall> ball = 0) {
  TinyPacketBuilder builder_(_fbb);
  builder_.add_ball(ball);
  builder_.add_players(players);
  return builder_.Finish();
}

inline flatbuffers::Offset<TinyPacket> CreateTinyPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TinyPlayer>> *players = nullptr,
    flatbuffers::Offset<TinyBall> ball = 0) {
  return rlbot::flat::CreateTinyPacket(
      _fbb,
      players ? _fbb.CreateVector<flatbuffers::Offset<TinyPlayer>>(*players) : 0,
      ball);
}

struct PredictionSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAMESECONDS = 4,
    VT_PHYSICS = 6
  };
  /// The moment in game time that this prediction corresponds to.
  /// This corresponds to 'secondsElapsed' in the GameInfo table.
  float gameSeconds() const {
    return GetField<float>(VT_GAMESECONDS, 0.0f);
  }
  /// The predicted location and motion of the object.
  const Physics *physics() const {
    return GetPointer<const Physics *>(VT_PHYSICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GAMESECONDS) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           verifier.EndTable();
  }
};

struct PredictionSliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gameSeconds(float gameSeconds) {
    fbb_.AddElement<float>(PredictionSlice::VT_GAMESECONDS, gameSeconds, 0.0f);
  }
  void add_physics(flatbuffers::Offset<Physics> physics) {
    fbb_.AddOffset(PredictionSlice::VT_PHYSICS, physics);
  }
  explicit PredictionSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PredictionSliceBuilder &operator=(const PredictionSliceBuilder &);
  flatbuffers::Offset<PredictionSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PredictionSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<PredictionSlice> CreatePredictionSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    float gameSeconds = 0.0f,
    flatbuffers::Offset<Physics> physics = 0) {
  PredictionSliceBuilder builder_(_fbb);
  builder_.add_physics(physics);
  builder_.add_gameSeconds(gameSeconds);
  return builder_.Finish();
}

struct BallPrediction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLICES = 4
  };
  /// A list of places the ball will be at specific times in the future.
  /// It is guaranteed to sorted so that time increases with each slice.
  /// It is NOT guaranteed to have a consistent amount of time between slices.
  const flatbuffers::Vector<flatbuffers::Offset<PredictionSlice>> *slices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PredictionSlice>> *>(VT_SLICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLICES) &&
           verifier.Verify(slices()) &&
           verifier.VerifyVectorOfTables(slices()) &&
           verifier.EndTable();
  }
};

struct BallPredictionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PredictionSlice>>> slices) {
    fbb_.AddOffset(BallPrediction::VT_SLICES, slices);
  }
  explicit BallPredictionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BallPredictionBuilder &operator=(const BallPredictionBuilder &);
  flatbuffers::Offset<BallPrediction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BallPrediction>(end);
    return o;
  }
};

inline flatbuffers::Offset<BallPrediction> CreateBallPrediction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PredictionSlice>>> slices = 0) {
  BallPredictionBuilder builder_(_fbb);
  builder_.add_slices(slices);
  return builder_.Finish();
}

inline flatbuffers::Offset<BallPrediction> CreateBallPredictionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PredictionSlice>> *slices = nullptr) {
  return rlbot::flat::CreateBallPrediction(
      _fbb,
      slices ? _fbb.CreateVector<flatbuffers::Offset<PredictionSlice>>(*slices) : 0);
}

inline const rlbot::flat::QuickChat *GetQuickChat(const void *buf) {
  return flatbuffers::GetRoot<rlbot::flat::QuickChat>(buf);
}

inline const rlbot::flat::QuickChat *GetSizePrefixedQuickChat(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rlbot::flat::QuickChat>(buf);
}

inline bool VerifyQuickChatBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rlbot::flat::QuickChat>(nullptr);
}

inline bool VerifySizePrefixedQuickChatBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rlbot::flat::QuickChat>(nullptr);
}

inline void FinishQuickChatBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rlbot::flat::QuickChat> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedQuickChatBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rlbot::flat::QuickChat> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace rlbot

#endif  // FLATBUFFERS_GENERATED_RLBOT_RLBOT_FLAT_H_
